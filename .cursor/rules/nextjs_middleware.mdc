---
description: Guidelines for implementing Next.js Middleware
globs: src/middleware.ts, middleware.ts, src/middleware.js, middleware.js
alwaysApply: true
---
# Specify the following for Cursor rules
description: Guidelines for implementing Next.js Middleware
globs: "src/middleware.ts, middleware.ts, src/middleware.js, middleware.js"
---

# Next.js Middleware

## Overview

Next.js Middleware allows you to run code before a request is completed. It enables you to modify the response by rewriting, redirecting, modifying the request or response headers, or responding directly.

## File Location

Middleware must be defined in either:
- `middleware.ts` (or `.js`) in the project root
- `src/middleware.ts` (or `.js`)

## Required Structure

```typescript
import { NextResponse } from 'next/server';
import type { NextRequest } from 'next/server';

// Basic middleware function
export function middleware(request: NextRequest) {
  // Your middleware logic here
  return NextResponse.next();
}

// Optional config for path matching
export const config = {
  matcher: '/api/:path*',
};
```

## ðŸš¨ CRITICAL RULES ðŸš¨

1. Always **return a response** from your middleware function:
   - `NextResponse.next()` - Continues to the next middleware or route
   - `NextResponse.redirect()` - Redirects to another URL
   - `NextResponse.rewrite()` - Rewrites to another URL invisibly
   - A new `NextResponse` object

2. When working with cookies in middleware with Supabase, you MUST use the exact cookie handling pattern:

```typescript
import { createServerClient } from '@supabase/ssr';
import { NextResponse, type NextRequest } from 'next/server';

export async function middleware(request: NextRequest) {
  let supabaseResponse = NextResponse.next({
    request,
  });

  const supabase = createServerClient(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        getAll() {
          return request.cookies.getAll();
        },
        setAll(cookiesToSet) {
          cookiesToSet.forEach(({ name, value, options }) => request.cookies.set(name, value));
          supabaseResponse = NextResponse.next({
            request,
          });
          cookiesToSet.forEach(({ name, value, options }) =>
            supabaseResponse.cookies.set(name, value, options)
          );
        },
      },
    }
  );

  // IMPORTANT: fetch the user immediately after client creation
  const {
    data: { user },
  } = await supabase.auth.getUser();

  // Your middleware logic here

  return supabaseResponse;
}
```

## Path Matching

Use the `config.matcher` option to filter paths where middleware executes:

```typescript
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     */
    '/((?!_next/static|_next/image|favicon.ico).*)',
  ],
};
```

## Best Practices

1. Keep middleware lightweight - it runs on every request to matched paths
2. Handle errors properly to avoid breaking the request pipeline
3. Use environment variables for configurations
4. Test middleware with various request scenarios
5. Be careful with redirects to avoid infinite loops
6. Always return the correct response type

## Common Use Cases

1. Authentication checks
2. Rate limiting
3. Bot protection
4. A/B testing
5. Header manipulation
6. Geolocation routing
7. Logging and analytics

## Debugging

Add `console.log` statements to debug middleware execution. These will appear in your terminal/console when running in development.

```typescript
export function middleware(request: NextRequest) {
  console.log('Middleware executed for:', request.nextUrl.pathname);
  return NextResponse.next();
}
```

Remember that middleware runs on both server and edge runtimes, so ensure your code is compatible with both environments. 